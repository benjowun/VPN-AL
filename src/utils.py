from isakmp import *
from aalpy.utils import *
import random

valid_names = ['Encryption', 'KeyLength', 'Hash',
               'GroupDesc', 'Authentication', 'LifeType', 'LifeDuration']
debug = False
libre = True

# model: {state, {input, (new_state, output)}}


class state_machine():
    def __init__(self, model) -> None:
        self._model = model[1]
        self._state = model[0]  # starting state
        self._start = model[0]  # starting state

    # goes to next state, returning output
    def next(self, input):
        if (next := self._model[self._state][input]) != None:
            print(
                f"  Â§ - State machine transition from {self._state} to {next[0]} via {input}")
            self._state = next[0]
            return next[1]
        else:
            raise NameError()

    # does random state transition, returing input/output tuple
    def rand_next(self):
        choices = self._model[self._state].keys()
        input = random.choice(choices)
        return (input, self.next(input))

    def get_state(self):
        return self._state

    def reset(self):
        self._state = self._start


def get_transform_value(list, name):
    assert(name in valid_names)

    for v in list:
        if v[0] == name:
            return v[1]


def show(packet):
    if debug:
        packet.show()


def dprint(data):
    if debug:
        print(data)

# shows if a returned packet is encrypted


def is_encypted(packet):
    #print(f"Flags: {packet[ISAKMP].flags}")
    # TODO: ensure it also works for other combinations (bit set)
    return packet[ISAKMP].flags == 1

# returns a printable representation of a bytearray


def hexify(data: bytes):
    hd = "".join("%02x " % b for b in data)
    return hd


def get_rand_runs(amount=10000, name="logs.txt"):
    l_file = open(name, "r")
    lines = l_file.read().splitlines()

    if amount > len(lines):
        ret = []
        for i in lines:
            if len(i) > 0:
                ret.append([i])
        return ret
    else:
        ret = []
        for i in range(amount):
            ret.append([random.choice(lines)])
        return ret

# returns a tuple with the start state and the model


def read_dot(name="LearnedModel.dot"):
    # d_file = open(name, "r")
    # lines = d_file.read().splitlines()
    # starting_state = ""
    # states = {}
    # # since the dot file is autogenerated we assume it is well formed
    # # parses into dictÂ² --> {state, {input, (new_state, output)}}
    # for line in lines:
    #     if "{" in line or "}" in line or "__start0" in line:
    #         continue  # skip first and last line
    #     elif "->" in line:
    #         line = line.split(" ")
    #         dprint(line)
    #         start = line[0]
    #         dest = line[2]
    #         label = line[4].split('"')[1].split("/")
    #         transition = label[0]
    #         output = label[1]
    #         dprint(
    #             f"l: {line}, s: {start}, e: {dest}, t: {transition}, o: {output}")

    #         states[start][transition] = (dest, output)
    #     else:  # found state
    #         state = line.split(" ")[0]
    #         states[state] = {}
    #         if starting_state == "":
    #             dprint("Updated starting_state")
    #             starting_state = state
    # return (starting_state, states)

    # use aalpy built-in function:
    mealy_machine = load_automaton_from_file(name, automaton_type='mealy')
    return mealy_machine