\chapter{Introduction}
\label{chap:Introduction}

\section{Motivation}
\ac{vpn} are used to allow secure communication over an insecure channel. They function by creating a secure encrypted tunnel through which users can send their data. Example use cases include additional privacy from prying eyes such as Internet Server Providers, access to region-locked online content and secure remote access to company networks. The importance of \ac{vpn} software has increased dramatically since the beginning of the COVID-19 pandemic due to the influx of people working from home \cite{DBLP:journals/cacm/FeldmannGLPPDWW21}. This makes finding vulnerabilities in \ac{vpn} software more critical than ever. % state reports on damages by vpn errors? 
% IPSEC
\ac{ipsec} is a popular \ac{vpn} protocol suite and most commonly uses the \ac{ike} protocol to share authenticated keying material between involved parties. Therefore, \ac{ike} and \ac{ipsec} are sometimes used interchangeably. We will stick to the official nomenclature of using \ac{ipsec} for the full protocol and \ac{ike} for the key exchange only. \ac{ike} has two versions, \ac{ike}v1~\cite{rfc:ikev1} and \ac{ike}v2~\cite{rfc:ikev2}, with \ac{ike}v2 being the newer and recommended version, according to a report by the National Institute of Standards and Technology~\cite{nist791491}. However, despite \ac{ike}v2 supposedly replacing its predecessor, \ac{ike}v1, sometimes also called Cisco \ac{ipsec}, is still in widespread use today. This is reflected by the company AVM to this day mainly offering \ac{ike}v1 support for their popular FRITZ!Box routers \cite{avm2022}. Additionally, \ac{ike}v1 is also used for the L2TP/\ac{ipsec} protocol, one of the most popular \ac{vpn} protocols according to NordVPN \cite{nordvpn2021}. The widespread usage of \ac{ipsec}-\ac{ike}v1, combined with its relative age and many options makes it an interesting target for security testing.

\section{Research Problem and Goals}
% Automata Learning
Behavioral models are a useful tool in testing and verifying the correctness of complex systems. A model simulating the behavior of a system gives an abstract high-level overview of its inner workings, allowing for much easier understanding than code review. Additionally, the model can be used e.g., to automatically generate test cases, or to fingerprint/detect specific software implementations \cite{pferscher2021fingerprinting, pferscher2022fuzzing}. Despite their usefulness, the availability of accurate models may be limited for the several reasons. Firstly, the manual creation of an accurate behavioral model of a complex system can be a tedious and error-prone process. Secondly, the model must be updated every time the system is changed, i.e., functionality is added or changed in any way. Automata learning has proven itself to be a useful technique for automatically generating behavioral models of various communication protocols, e.g., Bluetooth Low Energy~\cite{pferscher2021fingerprinting}, TCP~\cite{DBLP:conf/cav/Fiterau-Brostean16}, SSL~\cite{DBLP:conf/spin/Fiterau-Brostean17} or MQTT~\cite{tappler2017}. 

\Ac{aal} is an automata learning technique in which a behavioral model is generated by actively querying a system to gain information about it. Notable examples of \ac{aal} algorithms include the $L^*$ algorithm by Angluin \cite{angluin1987learning} and the $KV$ algorithm by Kearns and Vazirani \cite{KV1994}. \ac{aal} is of particular interest for security testers, as it can also be applied to systems where knowledge about its inner workings is lacking, e.g., due to its implementation code being closed-source. We call such systems black-box systems. It is not unusual for \acp{vpn} and other security-critical software to be closed-source and therefore a black-box system for testers. Fortunately, \ac{aal} allows for the creation of a behavioral model of a black-box system, which can then be used for model-based testing approaches. 

When testing complex systems, such as network protocol implementations, a popular testing technique is fuzz testing or fuzzing. During fuzzing, a system is bombarded by a large amount of random, invalid or otherwise unusual data, with the goal of triggering unexpected behavior. If such behavior is discovered, it can then be further examined by professionals or other software. Two important aspects while fuzzing are on the one hand, choosing what exactly to fuzz, and, furthermore, how unexpected behavior is defined/discovered by the fuzzer. Especially when fuzzing black-box systems, intelligent fuzzing can be difficult, as usually no information about the underlying source code is available. This makes choosing the fuzzing targets, as well as deciding which responses constitute interesting, unexpected behavior more challenging. The goal of this thesis is to showcase, how automata learning can be combined with fuzzing, in order to intelligently test a target black-box system. To this end, we first learned a model of the target system and subsequently used the learned model for model-based fuzzing. In model-based fuzzing, the learned model of a target black-box system can be used as a frame of reference to determine if unexpected behavior has been successfully discovered. 

By combining automata learning with fuzzing or similar software testing techniques, network protocols can be extensively and automatically tested without requiring access to their source code. Guo et al.~\cite{guo2019model} tested \ac{ipsec}-\ac{ike}v2 using automata learning and model checking, however so far, no studies have focused on \ac{ike}v1 in the context of automata learning. Therefore, we chose the \ac{ipsec}-\ac{ike}v1 protocol as the focus of this thesis, using automata learning in combination with automata-based fuzzing to automatically learn and test two \ac{ipsec} server implementation. We used the learning framework \textsc{AALpy}~\cite{software:aalpy} with a custom mapper to actively learn the state machines of two popular \ac{ipsec}-\ac{ike}v1 server implementations. We then further utilized the learned models for model-based fuzzing, creating a custom fuzzing framework supporting multiple types of input-sequence generation (sequences of inputs, where individual inputs are to be fuzzed). Drawing inspiration from search-based testing techniques~\cite{fuzzingbook2023:SearchBasedFuzzer}, we implemented search-based and genetic input-sequence generation methods. 

In doing so, several deviations from the RFC specification, a potential deadlock state and a cryptographic Python library bug were discovered.


\section{Structure}
This thesis is structured as follows. Chapter~\ref{chap:Related} gives an overview of the related literature. It focuses on automata learning of security-critical communication protocols, as well as model-based testing. Additionally, an examination of automated testing for \ac{vpn} protocols, particularly \ac{ipsec}-\ac{ike}v1 and \ac{ipsec}-\ac{ike}v2, is presented. Chapter~\ref{chap:Preliminaries} introduces necessary background knowledge, covering the \ac{ipsec}-\ac{ike}v1 protocol, Mealy machines, automata learning and fuzzing. First Mealy machines are introduced, as they are well suited to model reactive systems such as an \ac{ipsec} server implementation. Subsequently, automata learning and especially the \ac{mat} framework is explained, also highlighting the key differences between the two learning algorithms used in this thesis, $L^*$ and $KV$. Following that, an overview of fuzzing is given, explaining different types of fuzzers and introducing the fuzzer used in this thesis. Finally, the \ac{ipsec}-\ac{ike}v1 protocol is explained in detail, going over a typical exchange between two parties. Chapter~\ref{chap:Setup} covers our \ac{vpn} setup, \ac{ipsec} configurations and test environment. Our learning setup, custom mapper and solutions to non-determinism problems are presented in Chapter~\ref{chap:Learning}. Code excerpts serve to illustrate key features of our custom mapper class. Following model learning, our fuzzing methodology and input-sequence generation are explained in Chapter~\ref{chap:Fuzzing}.  In Chapter~\ref{chap:Evaluation}, learned models of both \ac{ipsec} implementations and the results of the corresponding fuzzing tests are showcased and analyzed. Additionally, a detailed performance comparison between the two used learning algorithms, $L^*$ and $KV$, is presented. Furthermore, the various methods of input-sequence generation used during fuzzing are evaluated.
Finally, Chapter~\ref{chap:Conclusion} summarizes the thesis and discusses future work.